#!/usr/bin/env -S deno run -A
import { parse as parseYaml } from "jsr:@std/yaml";
import { basename, dirname, join } from "jsr:@std/path";
import { ensureDirSync, existsSync } from "jsr:@std/fs";
import { parse as parseArgs } from "jsr:@std/flags";
import { parse as parseCsv } from "jsr:@std/csv";
import { exit } from "node:process";

// Types
type Profile = { path: string } | { url: string };

type FinallyCommand = {
  title: string;
  if: string;
  then: string;
};

type SkillRepo = {
  url: string;
};

type Config = {
  profile?: Profile[];
  finally?: FinallyCommand[];
  skills?: SkillRepo[];
};

// Constants
const VERSION = "1.0.0";
const DEFAULT_CONFIG_FILE = "prof.yaml";
const INIT_CONFIG = `# prof configuration
profile:
  - url: https://github.com/dineshdb/profile-template

finally:
  - title: "Example command"
    if: "[ -f /path/to/file ]"
    then: "echo 'File exists, running command'"

skills:
  - url: https://github.com/example/claude-skills
`;

// State
let configPath = DEFAULT_CONFIG_FILE;
const homeDir = Deno.env.get("HOME") ?? Deno.cwd();
const CACHE_DIR = join(homeDir, ".cache/prof");
const skillsCacheDir = join(CACHE_DIR, "skills");
const profilesCacheDir = join(CACHE_DIR, "profiles");
const claudeSkillsDir = join(homeDir, ".claude/skills");

// Logging utilities
const log = {
  info: (msg: string) => console.info(msg),
  success: (msg: string) => console.log(`✓ ${msg}`),
  warn: (msg: string) => console.warn(`⚠ ${msg}`),
  error: (msg: string) => console.error(`✗ ${msg}`),
};

// Command execution
function exec(
  command: string,
  options: { silent?: boolean; piped?: boolean } = { piped: true },
): { success: boolean; output?: string } {
  const process = new Deno.Command("bash", {
    args: ["-c", command],
    stdout: options.piped ? "piped" : "inherit",
    stderr: options.piped ? "piped" : "inherit",
  });

  const result = process.outputSync();
  const output = options.silent
    ? undefined
    : options.piped
      ? new TextDecoder().decode(result.stdout).trim()
      : undefined;

  return { success: result.success, output };
}

// Core functions
function initConfig(): void {
  if (existsSync(configPath)) {
    log.error("Configuration file already exists");
    exit(1);
  }

  Deno.writeTextFileSync(configPath, INIT_CONFIG);
  log.success(`Created ${configPath}`);
}

function loadConfig(configPath: string): Config {
  const content = Deno.readTextFileSync(configPath);
  return parseYaml(content) as Config;
}

function loadProfileConfig(profileDir: string): Config | null {
  const configPath = join(profileDir, "prof.yaml");
  return existsSync(configPath) ? loadConfig(configPath) : null;
}

function collectAllProfiles(profiles: Profile[]): Profile[] {
  const allProfiles: Profile[] = [];
  const visited = new Set<string>();

  function collectProfile(profile: Profile) {
    const profileDir = resolveProfile(profile);
    if (!profileDir || visited.has(profileDir)) return;

    visited.add(profileDir);
    const profileConfig = loadProfileConfig(profileDir);

    if (profileConfig?.profile?.length) {
      for (const dep of profileConfig.profile) {
        if (!("path" in dep) || dep.path !== ".") {
          collectProfile(dep);
        }
      }
    }

    allProfiles.push({ path: profileDir });
  }

  profiles.forEach(collectProfile);
  return allProfiles;
}

function resolveProfile(profile: Profile): string | null {
  if ("url" in profile) {
    const profileName = basename(profile.url).replace(/\.git$/, "");
    const localPath = join(profilesCacheDir, profileName);

    ensureDirSync(profilesCacheDir);
    cloneUpdate(localPath, profile.url);
    log.success(`Updated ${profileName}`);
    return localPath;
  }

  return existsSync(profile.path) ? profile.path : (() => {
    log.warn(`Profile path does not exist: ${profile.path}`);
    return null;
  })();
}

function ensureConfigExists(): void {
  if (!existsSync(configPath)) {
    log.error(`Configuration file not found: ${configPath}`);
    log.info("Run 'prof init' to create one");
    exit(1);
  }
}

function copyFiles(src: string, dest: string): void {
  exec(`test -e "${src}" && mkdir -p "${dest}" && cp -rf "${src}/" "${dest}/"`);
}

function applyProfile(profileDir: string): FinallyCommand[] {
  log.info(`Applying ${basename(profileDir)}`);

  // Copy configuration files
  const configDir = join(profileDir, "config");
  copyFiles(join(configDir, "~"), homeDir);
  copyFiles(join(profileDir, "home"), homeDir);
  installFirefoxUserJs(profileDir);

  const sshCsvPath = join(profileDir, "config/ssh.csv");
  if (existsSync(sshCsvPath)) {
    generateSshConfig(sshCsvPath);
  }

  // Collect profile-specific finalizers
  const profileConfig = loadProfileConfig(profileDir);
  if (profileConfig?.finally?.length) {
    return profileConfig.finally;
  }

  return [];
}

function executeFinalCommand(command: FinallyCommand): void {
  if (exec(command.if, { silent: true }).success) {
    const execResult = exec(command.then, { piped: true });
    const logFn = execResult.success ? log.success : log.error;
    logFn(`${execResult.success ? "" : "Failed: "}${command.title}`);
  }
}

function generateGitconfigInclude(): void {
  const gitconfigDir = join(homeDir, ".config/gitconfig.d");
  const includeFile = join(gitconfigDir, "_include.conf");

  try {
    ensureDirSync(gitconfigDir);

    const configFiles = Array.from(Deno.readDirSync(gitconfigDir))
      .filter((f) =>
        f.isFile && f.name.endsWith(".conf") && !f.name.startsWith("_")
      );

    if (configFiles.length > 0) {
      const content = "[include]\n" +
        configFiles.map((f) => `    path = ${f.name}\n`).join("");
      Deno.writeTextFileSync(includeFile, content);
    }
  } catch (error) {
    log.error(`Failed to generate gitconfig include: ${String(error.message ?? error)}`);
  }
}

function generateSshConfig(sshCsvPath: string): void {
  try {
    const records = parseCsv(Deno.readTextFileSync(sshCsvPath), {
      skipFirstRow: true,
      columns: ["name", "user", "ip", "port"],
    });

    const validRecords = records.filter((r: any) =>
      r.name?.trim() && r.user?.trim() && r.ip?.trim()
    );

    if (validRecords.length === 0) {
      log.warn("No valid SSH entries found in CSV file");
      return;
    }

    const sshConfigDir = join(homeDir, ".ssh", "conf.d");
    ensureDirSync(sshConfigDir);

    const configContent =
      "# Generated SSH config using prof\n# Do not edit manually - regenerate with 'prof apply'\n\n" +
      validRecords.map((record) => {
        const [host, user, hostname, port = "22"] = [
          record.name.trim(),
          record.user.trim(),
          record.ip.trim(),
          record.port?.trim(),
        ];
        return `Host ${host}\n    HostName ${hostname}\n    User ${user}\n    Port ${port}\n    StrictHostKeyChecking accept-new\n\n`;
      }).join("");

    Deno.writeTextFileSync(join(sshConfigDir, "sshcsv.conf"), configContent);
  } catch (error) {
    log.error(`Failed to generate gitconfig include: ${String(error.message ?? error)}`);
  }
}

function apply(): void {
  ensureConfigExists();

  const config = loadConfig(configPath);
  const profiles = config.profile ?? [];

  if (profiles.length === 0) {
    log.warn("No profiles found in configuration");
    return;
  }

  log.info(`Found ${profiles.length} profile(s)`);
  log.info("Resolving profile dependencies...");

  const allProfiles = collectAllProfiles(profiles);
  log.info(`Applying ${allProfiles.length} profiles...`);

  const allFinalizers = allProfiles
    .filter((p) => "path" in p)
    .flatMap((p) => applyProfile(p.path));

  if (allFinalizers.length > 0) {
    log.info(`Executing ${allFinalizers.length} finalizer(s)...`);
    allFinalizers.forEach(executeFinalCommand);
  }

  if (config.skills?.length) {
    log.info(`Adding skills from ${config.skills.length} repositories`);
    config.skills.forEach((repo) => setupSkill(repo.url));
  }

  generateGitconfigInclude();
}

function clean(): void {
  const cacheRoot = join(homeDir, ".cache/prof");
  exec(`rm -rf "${cacheRoot}"`);
  log.success("Cache cleaned");
}

function cloneUpdate(targetDir: string, repoUrl: String) {
  if (existsSync(targetDir)) {
    const pullResult = exec(`cd "${targetDir}" && git fetch && git reset --hard origin/HEAD`, {
      silent: true,
    });

    if (!pullResult.success) {
      log.error("Error pulling repository");
      exit(1);
    }
  } else {
    let cloneResult = exec(`git clone ${repoUrl} "${targetDir}"`);
    if (!cloneResult.success) {
      log.error("Error cloning repository");
      exit(1);
    }
  }
}

function setupSkill(repoUrl: string): void {
  const skillCacheDir = join(
    skillsCacheDir,
    repoUrl.replace(/^https?:\/\/[^\/]+\//, "").replace(/\.git$/, ""),
  );

  ensureDirSync(dirname(skillCacheDir));
  ensureDirSync(claudeSkillsDir);

  log.info(`Cloning ${repoUrl}...`);
  cloneUpdate(skillCacheDir, repoUrl);

  log.info("Installing skills...");
  const findResult = exec(
    `find "${skillCacheDir}" -name "SKILL.md" -exec dirname {} \\;`,
    { piped: true },
  );

  if (findResult.success && findResult.output) {
    findResult.output.trim().split("\n")
      .filter((dir) => dir.trim())
      .forEach((skillDir) => exec(`cp -rf "${skillDir}" ${claudeSkillsDir}/`));
  }

  log.success("Done!");
}

function findFirefoxProfiles(): string[] {
  const profilePaths: string[] = [];

  const findInDir = (
    dir: string,
    callback: (entry: Deno.DirEntry) => boolean,
  ) => {
    if (existsSync(dir)) {
      try {
        Deno.readDirSync(dir).forEach(callback);
      } catch (error) {
        log.warn(`Could not read directory ${dir}: ${error}`);
      }
    }
  };

  // macOS Firefox profiles
  const profilesDir = "Library/Application Support/Firefox/Profiles";
  const userProfilesDir = join(homeDir, profilesDir);
  findInDir(
    userProfilesDir,
    (entry) => {
      if (entry.isDirectory && entry.name.includes(".default")) {
        profilePaths.push(
          join(
            userProfilesDir,
            entry.name,
          ),
        );
      }
      return true;
    },
  );

  // Linux Firefox profiles
  findInDir(join(homeDir, ".mozilla/firefox"), (entry) => {
    if (entry.isDirectory && entry.name.includes(".default")) {
      const fullPath = join(homeDir, ".mozilla/firefox", entry.name);
      if (!profilePaths.includes(fullPath)) {
        profilePaths.push(fullPath);
      }
    }
    return true;
  });

  const profilesIni = join(homeDir, ".mozilla/firefox/profiles.ini");
  if (existsSync(profilesIni)) {
    try {
      const content = Deno.readTextFileSync(profilesIni);
      content.match(/^Path=(.+)$/gm)?.forEach((match) => {
        const path = match.split("=")[1].trim();
        if (path.includes("default")) {
          const fullPath = join(homeDir, ".mozilla/firefox", path);
          if (!profilePaths.includes(fullPath)) {
            profilePaths.push(fullPath);
          }
        }
      });
    } catch (error) {
      log.warn(`Could not read profiles.ini: ${error}`);
    }
  }

  return profilePaths;
}

function installFirefoxUserJs(profileDir: string): void {
  const userJsPath = join(profileDir, "home/.mozilla/user.js");
  if (!existsSync(userJsPath)) return;

  const profiles = findFirefoxProfiles();

  if (profiles.length === 0) {
    log.warn("No Firefox profiles found");
    return;
  }

  log.info(`Installing user.js to ${profiles.length} Firefox profile(s)...`);

  const successCount = profiles.reduce((count, profile) => {
    try {
      Deno.copyFileSync(userJsPath, join(profile, "user.js"));
      log.success(`Installed user.js to ${basename(profile)}`);
      return count + 1;
    } catch (error) {
      log.error(`Failed to install user.js to ${basename(profile)}: ${error}`);
      return count;
    }
  }, 0);

  log.info(`Installed user.js to ${successCount}/${profiles.length} profiles`);
}

function showHelp(): void {
  console.log(`prof - Simple profile composition tool v${VERSION}

USAGE:
    deno run -A prof [OPTIONS] <command>

OPTIONS:
    -c, --config <file>    Use specified config file (default: ${DEFAULT_CONFIG_FILE})
    -h, --help            Show this help message
    --version             Show version information

COMMANDS:
    init                  Initialize a new configuration file
    apply                 Apply all profiles from configuration
    clean                 Clean up cached files
    help                  Show this help message`);
}

// Main execution
function main(): void {
  const flags = parseArgs(Deno.args, {
    boolean: ["help", "version"],
    string: ["config"],
    alias: { config: "c", help: "h" },
    default: { config: DEFAULT_CONFIG_FILE },
  });

  configPath = flags.config;

  if (flags.help || flags._[0] === "help") {
    showHelp();
    return;
  }

  if (flags.version) {
    console.log(`prof version ${VERSION}`);
    return;
  }

  const command = flags._[0] as string;

  try {
    switch (command) {
      case "init":
        initConfig();
        break;
      case "apply":
        apply();
        break;
      case "clean":
        clean();
        break;
      case undefined:
        showHelp();
        break;
      default:
        log.error(`Unknown command: ${command}`);
        console.log("Run 'prof --help' for usage information.");
        Deno.exit(1);
    }
  } catch (err) {
    log.error(`Error: ${err instanceof Error ? err.message : String(err)}`);
    Deno.exit(1);
  }
}

if (import.meta.main) {
  main();
}
